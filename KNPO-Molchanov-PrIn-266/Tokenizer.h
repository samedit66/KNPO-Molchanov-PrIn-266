#pragma once

#include <vector>
#include <set>
#include <regex>


/// Допустимые токены языка псевдо-ассмеблера
enum class TOKEN_TYPE {
	STRING, ///< Cтрока в кавычках
	DECIMAL_NUMBER, ///< Число в десятичной форме записи
	HEX_NUMBER, ///< Число в шестнадцатиричной форме записи
	OCTAL_NUMBER, ///< Число в восьмиричной форме записи
	BINARY_NUMBER, ///< Число в двочиной форме записи
	CHAR, ///< Число в форме символьной константы
	NAME,   ///< Имя метки/переменной

	SPACE, ///< Пробельные символы
	COMMENT, ///< Комментарий

	COMMA, ///< Запятая
	COLON, ///< Двоеточие
	PLUS, ///< Плюс
	MINUS, ///< Минус

	ADD, ///< Зарезервированное слово "add"
	SUB, ///< Зарезервированное слово "sub"
	AND, ///< Зарезервированное слово "and"
	OR, ///< Зарезервированное слово "or"
	XOR, ///< Зарезервированное слово "xor"
	NOT, ///< Зарезервированное слово "not"
	SHR, ///< Зарезервированное слово "shr"
	SHL, ///< Зарезервированное слово "shl"

	SET, ///< Зарезервированное слово "set"

	LD, ///< Зарезервированное слово "ld"
	ST, ///< Зарезервированное слово "st"
	LDI, ///< Зарезервированное слово "ldi"
	STI, ///< Зарезервированное слово "sti"

	JMP, ///< Зарезервированное слово "jmp"
	JEQ, ///< Зарезервированное слово "jeq"
	JGT, ///< Зарезервированное слово "jgt"

	CALL, ///< Зарезервированное слово "call"
	RET, ///< Зарезервированное слово "ret"

	DATA, ///< Зарезервированное слово "data"

	R0, ///< Зарезервированное слово "r0"
	R1, ///< Зарезервированное слово "r1"
	R2, ///< Зарезервированное слово "r2"
	R3, ///< Зарезервированное слово "r3"
	R4, ///< Зарезервированное слово "r4"
	R5, ///< Зарезервированное слово "r5"
	R6, ///< Зарезервированное слово "r6"
	R7, ///< Зарезервированное слово "r7"

	UNSPECIFIED, ///< Значение, указывающее, что токен не определен
};

/*!
Класс, описывающий ошибку, возникающую в случае, если не было найдено 
соответствующего щаблона токена
*/
class NoTokenFoundError {
protected:
	/// Сообщение об ошибке
	std::string msg;

public:
	/*!
	Конструктор ошибки
	\param[in] m Сообщение об ошибке
	*/
	NoTokenFoundError(const std::string& m);

	/*
	Возвращает сообщение об ошибке
	\return сообщение об ошибке
	*/
	virtual std::string what() const;
};


/*
Представление токена в программе
*/
struct Token {
	/// Тип токена
	TOKEN_TYPE type;
	/// Тектовое представление токена
	std::string text;
	/// Индекс начала токена в строке
	int start_index;
	/// Индекс конца токена в строке
	int end_index;
};


/*!
Токенайзер для языка псевдо-ассмеблера
*/
class Tokenizer
{
private:
	/*!
	Класс, описывающий текстовый шаблон, соотвествующий данному типу токена
	*/
	class TokenRegex {
	private:
		/// Тип токена
		TOKEN_TYPE type;
		/// Регулярное выражение, соответствующее токену
		std::regex matching_regex;

	public:
		/*!
		Конструктор шаблона-токена
		\param[in] t Тип токена
		\param[in\ r Шаблон, описывающий токен
		*/
		TokenRegex(TOKEN_TYPE t, std::string r);

		/*!
		Возвращает тип токена для шаблона
		\return Тип токена для шаблона
		*/
		TOKEN_TYPE get_type();

		/*!
		Проверяет наличие токена в строке
		\param[in] str Строка для проверки
		\param[in] start_index Индекс с которого начинается поиск
		\param[out] m Объект, в котором хранятся данные о результате сопоставления
		\return Флаг, указывающий об успешности результата сопоставления
		*/
		bool match(const std::string& str, int start_index, std::smatch& m);
	};

	/// Допустимые шаблоны для токенов
	std::vector<TokenRegex> token_regexes;

	/// Типы токенов, которые нужно игнорировать в процессе разбора
	std::set<TOKEN_TYPE> ignored_tokens;

	/*!
	Добавляет новый шаблон соотвествующий данному типу токена
	\param[in] type Тип токена
	\param[in] matching_regex Шаблон для токена
	*/
	void add_token(TOKEN_TYPE type, const std::string& matching_regex);

	/*!
	Добавляет тип токена, который следует игнорировать в процессе разбора
	\param[in] type Тип токена
	*/
	void ignore(TOKEN_TYPE type);

	/*!
	\brief Выделяет следующий токен из строки-итератора
	
	Выделяет следующий токен из строки. В случае, когда токен не нужно игнорировать, он добавляется список токенов
	\param[in] str Строка из которой извлекаются токены
	\param[in] start_index Индекс с которого начнется поиск и извлечение токенов
	\param[out] tokens Считанные токены
	\return Индекс указывающий на символ, идущий сразу после найденого токена
	\throw NoTokenFoundError В случае, если не было найдено соответствующего шаблона для извлечения токена
	*/
	int extract_token(const std::string& str, int start_index, std::vector<Token>& tokens);

public:
	/*!
	Конструктор токенайзера, устанавливающий токены языка псевдо-ассемблера
	*/
	Tokenizer();

	/*!
	\brief Выделяет токены языка псевдо-ассемблера из строки

	Выделяет токены языка псевдо-ассмеблера из строки, добавляя их во входной вектор
	\param[in] str Входная строка
	\param[out] tokens Считанные токены
	*/
	void tokenize(const std::string& str, std::vector<Token>& tokens);
};